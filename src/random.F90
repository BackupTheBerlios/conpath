MODULE MARSAGLIAS
  USE SYSTEM_UTIL, ONLY : CPSTOP
  IMPLICIT NONE
  DOUBLE PRECISION, DIMENSION(97) :: U
  DOUBLE PRECISION :: C, CD, CM
  INTEGER :: I97, J97
  LOGICAL :: SET
  DATA SET /.FALSE./

CONTAINS

  SUBROUTINE AMRSET(ISEED)
    IMPLICIT NONE
!   INITIALIZATION ROUTINE FOR MARSAGLIAS RANDOM NUMBER GENERATOR
!   TESTING:  CALL AMRSET WITH ISEED = 54185253.  THIS SHOULD RESULT
!   IN IS1 = 1802 AND IS2 = 9373.  CALL AMRAND 20000 TIMES, THEN SIX
!   MORE TIMES, PRINTING THE SIX RANDOM NUMBERS * 2**24 (IE, 4096*4096)
!   THEY SHOULD BE: (6F12.1)
!   6533892.0  14220222.0  7275067.0  6172232.0  8354498.0  10633180.0
!
!   INPUT:

    INTEGER, INTENT(IN) :: ISEED
! ... INTEGER SEED GREATER THAN ZERO
!
!     INTERNAL:
!
    INTEGER :: IS1, IS2
! ... THE TWO INTERNAL SEEDS USED IN MARSAGLIA ALGORITHM
    INTEGER :: IS1MAX
! ... MAX VALUE OF FIRST SEED (IS1), 31328
    INTEGER :: IS2MAX
! ... MAX VALUE OF SECOND SEED (IS2), 30081
    INTEGER :: I, J, K, L, M
! ... USED IN GENERATION OF U()
    DOUBLE PRECISION :: S, T
! ... USED IN GENERATION OF U()
    INTEGER :: II, JJ
! ... LOOP INDICES
    DATA IS1MAX, IS2MAX /31328, 30081/
! 
!     --- CONSTRUCT TWO INTERNAL SEEDS FROM SINGLE UNBOUND SEED ---
! 
!         IS1 AND IS2 ARE QUOTIENT AND REMAINDER OF ISEED/IS2MAX.  WE ADD
!         ONE TO KEEP ZERO AND ONE RESULTS FROM BOTH MAPPING TO ONE.
!         MAX AND MIN FUNCTIONS KEEP IS1 AND IS2 IN REQUIRED BOUNDS.    
    IS1 = MAX((ISEED / IS2MAX)+1, 1)
    IS1 = MIN(IS1, IS1MAX)
    IS2 = MAX(1, MOD(ISEED, IS2MAX)+1)
    IS2 = MIN(IS2, IS2MAX)
!
    I = MOD(IS1/177, 177) + 2
    J = MOD(IS1    , 177) + 2
    K = MOD(IS2/169, 178) + 1
    L = MOD(IS2    , 169)
    DO II = 1, 97
       S = 0.0D0
       T = 0.5D0
       DO  JJ = 1, 24
          M = MOD(MOD(I*J, 179)*K, 179)
          I = J
          J = K
          K = M
          L = MOD(53*L+1, 169)
          IF (MOD(L*M, 64) .GE. 32) S = S + T
          T = 0.5D0 * T
       END DO
       U(II) = S
    END DO
    C  = 362436.0D0   / 16777216.0D0
    CD = 7654321.0D0  / 16777216.0D0
    CM = 16777213.0D0 / 16777216.0D0
    I97 = 97
    J97 = 33
!
    SET = .TRUE.
    RETURN
  END SUBROUTINE AMRSET

  
  DOUBLE PRECISION FUNCTION AMRAND ( ) 
    IMPLICIT NONE
!     PORTABLE RANDOM NUMBER GENERATOR BY GEORGE MARSAGLIA
!
!     OUTPUT:
!
!     AMRAND:  A RANDOM NUMBER BETWEEN 0.0 AND 1.0
!     INTERNAL:
!
    DOUBLE PRECISION :: UNI
! ... WORKING VAR. FOR RANDOM NUMBER
!
!     THIS RANDOM NUMBER GENERATOR ORIGINALLY APPEARED IN *TOWARD A UNIVERSAL
!     RANDOM NUMBER GENERATOR* BY GEORGE MARSAGLIA AND ARIF ZAMAN.  FLORIDA
!     STATE UNIVERSITY REPORT: FSU-SCRI-87-50 (1987)
!
!     IT WAS LATER MODIFIED BY F. JAMES AND PUBLISHED IN *A REVIEW OF PSEUDO-
!     RANDOM NUMBER GENERATORS*
!
!     THIS IS CLAIMED TO BE THE BEST KNOWN RANDOM NUMBER GENERATOR AVAILABLE.
!     IT PASSES ALL OF THE TESTS FOR RANDOM NUMBER GENERATORS AND HAS A
!     PERIOD OF 2^144, IS COMPLETELY PORTABLE (GIVES BIT IDENTICAL RESULTS ON
!     ALL MACHINES WITH AT LEAST 24-BIT MANTISSAS IN THE FLOATING POINT
!     REPRESENTATION).
!
!     THE ALGORITHM IS A COMBINATION OF A FIBONACCI SEQUENCE (WITH LAGS OF 97
!     AND 33, AND OPERATION "SUBTRACTION PLUS ONE, MODULO ONE") AND AN
!     "ARITHMETIC SEQUENCE" (USING SUBTRACTION).

    IF ( .NOT. SET ) THEN
       WRITE(6,'(A)') 'AMRAND NOT INITD'
       CALL CPSTOP('AMRAND')
    ENDIF
    UNI = U(I97) - U(J97)
    IF ( UNI .LT. 0.0D0 ) UNI = UNI + 1.0D0
    U(I97) = UNI
    I97 = I97 - 1
    IF (I97 .EQ. 0) I97 = 97
    J97 = J97 - 1
    IF (J97 .EQ. 0) J97 = 97
    C = C - CD
    IF ( C .LT. 0.0D0 ) C = C + CM
    UNI = UNI - C
    IF ( UNI .LT. 0.0D0 ) UNI = UNI + 1.0D0
    AMRAND = UNI
    
    RETURN
  END FUNCTION AMRAND



  DOUBLE PRECISION FUNCTION  GAUSS(AM,SD)
    IMPLICIT NONE

!    THIS IS A VERSION OF AMRAND() THAT ADDS THE CONSTRAINT OF
!    A GAUSSIAN DISTRIBUTION, WITH MEAN "AM" AND STANDARD DEVIATION "SD".
!    OUTPUT IS TO VARIABLE "GAUSS". IT ALSO REQUIRES AMRSET TO HAVE
!    BEEN CALLED FIRST, AND "USES UP" THE SAME SEQUENCE THAT
!    AMRAND() DOES.
    DOUBLE PRECISION, INTENT(IN)  :: AM, SD
    DOUBLE PRECISION :: A, UNI, ZERO, SIX
    INTEGER :: I
    DATA ZERO,SIX /0.0D0,6.0D0/
    IF ( .NOT. SET ) THEN
       WRITE(6,'(A)') 'AMRAND NOT INITD'
       CALL CPSTOP('GAUSS')
    ENDIF
    A = ZERO
    DO  I = 1, 12
       UNI = U(I97) - U(J97)
       IF ( UNI .LT. 0.0D0 ) UNI = UNI + 1.0D0
       U(I97) = UNI
       I97 = I97 - 1
       IF (I97 .EQ. 0) I97 = 97
       J97 = J97 - 1
       IF (J97 .EQ. 0) J97 = 97
       C = C - CD
       IF ( C .LT. 0.0D0 ) C = C + CM
       UNI = UNI - C
       IF ( UNI .LT. 0.0D0 ) UNI = UNI + 1.0D0
       A = A + UNI
    END DO
    GAUSS=(A-SIX)*SD+AM
    RETURN
  END FUNCTION GAUSS


  SUBROUTINE GAUSS_VEC(AM,SD,V,N)
    IMPLICIT NONE
!   THIS IS A VERSION OF AMRAND() THAT ADDS THE CONSTRAINT OF
!   A GAUSSIAN DISTRIBUTION, WITH MEAN "AM" AND STANDARD DEVIATION "SD".
!   OUTPUT IS TO VARIABLE "V". IT ALSO REQUIRES AMRSET TO HAVE
!   BEEN CALLED FIRST, AND "USES UP" THE SAME SEQUENCE THAT
!   AMRAND() DOES.
    DOUBLE PRECISION, DIMENSION(N), INTENT(OUT) :: V
    DOUBLE PRECISION, INTENT(IN) :: SD, AM
    DOUBLE PRECISION :: ZERO, SIX, A, UNI
    INTEGER, INTENT(IN) :: N
    INTEGER :: ITER, I
    DATA ZERO,SIX /0.0D0,6.0D0/
    IF ( .NOT. SET ) THEN
       WRITE(6,'(A)') 'AMRAND NOT INITD'
       CALL CPSTOP('GAUSS_VEC')
    ENDIF

    DO ITER=1,N
       A = ZERO
       DO I = 1, 12
          UNI = U(I97) - U(J97)
          IF ( UNI .LT. 0.0D0 ) UNI = UNI + 1.0D0
          U(I97) = UNI
          I97 = I97 - 1
          IF (I97 .EQ. 0) I97 = 97
          J97 = J97 - 1
          IF (J97 .EQ. 0) J97 = 97
          C = C - CD
          IF ( C .LT. 0.0D0 ) C = C + CM
          UNI = UNI - C
          IF ( UNI .LT. 0.0D0 ) UNI = UNI + 1.0D0
          A = A + UNI
       END DO
       V(ITER) = (A-SIX)*SD+AM
    END DO
    RETURN
  END SUBROUTINE GAUSS_VEC

END MODULE MARSAGLIAS
